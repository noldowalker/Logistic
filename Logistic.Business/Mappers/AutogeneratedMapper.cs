using System.Dynamic;
using System.Reflection;
using System.Text.Json;
using Domain.Models;

namespace Logistic.Application.Mappers;

public class AutogeneratedMapper<TDomain> where TDomain : BaseModel
{
    public object MapFromDomain(TDomain entity)
    {
        var type = entity.GetType();
        var result = new ExpandoObject() as IDictionary<string, object?>;
        foreach (var field in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            if (!field.CanRead)
                continue;

            result.Add(field.Name, field.GetValue(entity));
        }
        
        return result;
    }
    
    public TDomain? MapToDomain(JsonElement entity)
    {
        var type = typeof(TDomain);
        var constructor = type.GetConstructor(new Type[] {});
        var result = (TDomain) constructor?.Invoke(new TDomain[] { });
        
        foreach (var field in typeof(TDomain).GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            var isPropertyInRequest = entity.TryGetProperty(field.Name, out JsonElement requestProperty);
            
            if (!isPropertyInRequest)
                continue;

            var value = GetValueForPropertyInJson(field, requestProperty);
            field.SetValue(result, value);
        }
        
        return result;
    }

    private object? GetValueForPropertyInJson(PropertyInfo field, JsonElement value)
    {
        var valueKind = value.ValueKind;
        var propertyType = field.PropertyType.Name; 
        switch (propertyType)
        {
            case "Int64":
                return (valueKind == JsonValueKind.Number) ? value.GetInt64() : null;
            case "String":
                return (valueKind == JsonValueKind.String) ? value.GetString() : null;
            case "Boolean": 
                return valueKind is JsonValueKind.True or JsonValueKind.False ? value.GetBoolean() : null;
            default:
                return null;
        }
    }
    
}