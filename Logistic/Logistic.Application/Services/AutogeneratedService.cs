using System.Reflection;
using System.Text.Json;
using Domain.Interfaces;
using Domain.Models;
using FluentValidation;
using Logistic.Application.Interfaces;
using Logistic.Application.WorkResult;
using Microsoft.Extensions.DependencyInjection;

namespace Logistic.Application.Services;

public class AutogeneratedService<T> : IBusinessService<T> where T : BaseModel 
{
    public IBusinessActionMessageContainer Results { get; set; }
        
    private readonly IBaseModelsRepository<T> _repository;
    private readonly AbstractValidator<T> _validator;
    private readonly IServiceProvider _serviceProvider;
    
    public AutogeneratedService(
        IBaseModelsRepository<T> repository, 
        IBusinessActionMessageContainer results, 
        IServiceProvider serviceProvider,
        AbstractValidator<T> validator)
    {
        _repository = repository;
        Results = results;
        _serviceProvider = serviceProvider;
        _validator = validator;
    }
    
    public virtual BusinessResult<T> GetList()
    {
        var actionResult = _repository.GetList();
        
        return new BusinessResult<T>(actionResult);
    }
    
    public virtual BusinessResult<T> Get(long id)
    {
        var actionResult = _repository.Get(id);
        
        return new BusinessResult<T>(actionResult);
    }

    public virtual async Task<BusinessResult<T>> Create(List<T> entities)
    {
        var validEntities = new List<T>();
        foreach (var entity in entities)
        {
           var validationResult = _validator.Validate(
                entity, 
                options => options.IncludeRuleSets("Common", "Create"));

            if (!validationResult.IsValid)
            {
                Results.ConvertFromValidation(validationResult.Errors);
                continue;
            }
            
            validEntities.Add(entity);
        }

        var data = new List<T>();
        foreach (var validEntity in validEntities)
        {
            await UpdateLinks(validEntity);
            var actionResult = await _repository.Create(validEntity);
            
            Results.Messages.AddRange(actionResult.Messages);
            if (actionResult.IsSuccessful) 
                data.Add(validEntity);
        }

        return new BusinessResult<T>(data, Results.Messages, !Results.IsBroken);
    }

    public virtual async Task<BusinessResult<T>> Update(List<T> entities)
    {
        var validEntities = new List<T>();
        foreach (var entity in entities)
        {
            var validationResult = _validator.Validate(
                entity, 
                options => options.IncludeRuleSets("Common", "Update"));

            if (!validationResult.IsValid)
            {
                Results.ConvertFromValidation(validationResult.Errors);
                continue;
            }
            
            validEntities.Add(entity);
        }

        var data = new List<T>();
        foreach (var domainEntity in validEntities)
        {
            //ToDo: всплытие ошибок
            await UpdateLinks(domainEntity);
            var actionResult = await _repository.Update(domainEntity);

            Results.Messages.AddRange(actionResult.Messages);
            if (actionResult.IsSuccessful) 
                data.Add(domainEntity);
        }

        return new BusinessResult<T>(data, Results.Messages, !Results.IsBroken);
    }

    private async Task UpdateLinks(T entity)
    {
        var entityType = typeof(T);
        var baseModelType = typeof(BaseModel);
        
        foreach (var property in entityType.GetProperties())
        {
            if (!baseModelType.IsAssignableFrom(property.PropertyType))
                continue;
            
            var repoType = typeof(IBaseModelsRepository<>).MakeGenericType(property.PropertyType);
            var propertyRepo = _serviceProvider.GetRequiredService(repoType);
            if (propertyRepo == null)
                continue;
            
            var validatorType = typeof(AbstractValidator<>).MakeGenericType(property.PropertyType);
            var propertyValidator = _serviceProvider.GetRequiredService(validatorType);

            var method = repoType.GetMethod("Get", new Type[] { typeof(long) });
            if (method == null)
                continue;
            
            var linkValue = property.GetValue(entity); 
            if (linkValue == null)
                continue;

            MethodInfo getOrCreateMethod = GetType().GetMethod(nameof(GetOrCreatePropertyValue), BindingFlags.NonPublic | BindingFlags.Instance);
            MethodInfo genericMethod = getOrCreateMethod.MakeGenericMethod(property.PropertyType);
            var parameters = new object[] { linkValue, propertyRepo, propertyValidator };
            dynamic task = genericMethod.Invoke(this, parameters);
            var result = await task;
            
            if (result != null)
            {
                property.SetValue(entity, result);
            }
            
            property.SetValue(entity, result);
        }
    }
    
    private async Task<TLink?> GetOrCreatePropertyValue<TLink>(
        TLink valueInEntity, 
        IBaseModelsRepository<TLink> repository,
        IValidatable<TLink> validator) where TLink : BaseModel
    {
        TLink? data = null;
        if (valueInEntity.Id > 0)
        {
            if (!validator.IsValidForUpdate(valueInEntity))
                return null;
            
            var result = await repository.Update(valueInEntity);
            if (result.IsSuccessful)
                data = result.Data.First();
        }
        else
        {
            if (!validator.IsValidForCreate(valueInEntity))
                return null;
            
            var result = await repository.Create(valueInEntity);
            if (result.IsSuccessful)
                data = result.Data.First();
        }

        return data;
    }
}

