using System.Reflection;
using Domain.Attributes;
using Domain.Interfaces;
using Domain.Models;
using Logistic;
using Logistic.Infrastructure.Interfaces;
using Logistic.Infrastructure.Repositories;
using Logistic.Infrastructure.WorkResult;
using Microsoft.EntityFrameworkCore;

namespace Logistic.Infrastructure;

using Microsoft.Extensions.DependencyInjection;

public static class ConfigureServices
{
    public static void AddInfrastructure(this IServiceCollection services, string connectionString)
    {
        AddDbContext(services, connectionString, "Logistic.Infrastructure");
        AddInfrastructureDependencies(services);
        AddInfrastructureGeneration(services);
    }
    
    private static void AddDbContext(IServiceCollection services, string connectionString, string assemblyName)
    {
        services.AddDbContext<DataBaseContext> (o => o.UseNpgsql(connectionString, b => b.MigrationsAssembly(assemblyName)));
    }
        
    private static void AddInfrastructureDependencies(IServiceCollection services)
    {
        services.AddScoped<IBaseModelsRepository<Customer>, CustomersRepository>();
        services.AddScoped<IInfrastructureActionMessageContainer, InfrastructureMessagesContainer>();
    }

    private static void AddInfrastructureGeneration(IServiceCollection services)
    {
        AddAutogeneratedRepositories(services);
        AddInterceptors(services);
    }

    /// <summary>
    /// Добавляет для всех моделей с аттрибутом AutoGenerateAttribute по репозиторию.
    /// </summary>
    /// <param name="services"></param>
    private static void AddAutogeneratedRepositories(IServiceCollection services)
    {
        var autogeneratableTypes = AppDomain.CurrentDomain
            .GetAssemblies()
            .SelectMany(a => a.GetTypes())
            .Where(t => t.GetCustomAttributes(typeof(AutoGenerateAttribute), true).Any());

        foreach (var type in autogeneratableTypes)
        {
            var baseBusinessServiceType = typeof(AutogeneratedRepository<>).MakeGenericType(type);
            var baseBusinessInterfaceType = typeof(IBaseModelsRepository<>).MakeGenericType(type);

            services.AddScoped(baseBusinessInterfaceType, baseBusinessServiceType);
        }
    }

    /// <summary>
    /// Ищет в сборке все реализации интерфейса перехватчика действий и добавляет их в Scope
    /// </summary>
    /// <param name="services"></param>
    private static void AddInterceptors(IServiceCollection services)
    {
        var baseType = typeof(BaseModel);
        // ToDo: проверить что лучше, подгружать конкретную сборку через Load или искать по всем AppDomain.CurrentDomain.GetAssemblies()
        var assembly = Assembly.Load("Logistic.Domain");
        var types = assembly.GetTypes().Where(t => t.IsSubclassOf(baseType)).ToList();
        types.Add(baseType);
        
        foreach (var type in types)
        {
            AddInterceptorsForType(services, type, typeof(IInterceptAfterRead<>));
            AddInterceptorsForType(services, type, typeof(IInterceptBeforeCreate<>));
            AddInterceptorsForType(services, type, typeof(IInterceptAfterCreate<>));
            AddInterceptorsForType(services, type, typeof(IInterceptBeforeUpdate<>));
            AddInterceptorsForType(services, type, typeof(IInterceptAfterUpdate<>));
            AddInterceptorsForType(services, type, typeof(IInterceptBeforeDelete<>));
            AddInterceptorsForType(services, type, typeof(IInterceptBeforeDelete<>));
        }
    }
    
    private static void AddInterceptorsForType(IServiceCollection services, Type baseModelType, Type interceptorType)
    {
        // тут важно искать по конкретному типу, т.е. указать какой именно дженерик нас интересует. Иначе в сборке не найдет.
        //ToDo: реализовать подтягивание по цепочке типов, а не по конкретному, как в валидаторах. ???
        var interfaceType = interceptorType.MakeGenericType(baseModelType); 
        var interceptorTypes = AppDomain.CurrentDomain
            .GetAssemblies()
            .SelectMany(a => a.GetTypes())
            .Where(t => interfaceType.IsAssignableFrom(t));
        
        foreach (var type in interceptorTypes)
        {
            services.AddScoped(interfaceType, type);
        }
    }
}
